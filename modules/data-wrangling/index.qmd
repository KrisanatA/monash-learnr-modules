---
title: Data wrangling with R
subtitle: 'In this chapter, you will learn to use tidyr and dplyr from the tidyverse in R for tidying your data set and data maniplulation.'
title-block-banner: yes
engine: knitr
format:
  html:
    from: markdown+emoji
filters:
    - webr-teachr
webr:
    packages: [palmerpenguins, rlang, dplyr, tidyr]
---

```{r}
#| echo: false
#| output: false

# library
library(palmerpenguins)
library(tidyverse)
```

# Introduction to dplyr

**dplyr** provides a selection of tools for the most common data wrangling tasks. There are a few simple yet handy functions.

* `select()`
* `filter()`
* `arrange()`
* `mutate()`
* `group_by()` along with `ungroup()`
* `count()`
* `case_when()`


## select()

This function allows you to pick particular variables from your data.

```{r}
#| eval: false

data |>
    select(variable)
```

This is not only limited to one variable selection. You can select multiple variables by separating the column name with the comma.

```{r}
#| eval: false

data |>
    select(variable1, variable2)
```

::: {.callout-caution}
## Your turn!
We will be using penguin data from the palmerpenguins package.

Let's say that you want to look at whether the **body mass** changes over the **year**.

Hint: To look at the column names of the data, you can use the functions `colnames()`
:::

```{webr-teachr}
# library the packages needed
library(palmerpenguins)
library(dplyr)

# Select the column of interests
penguins |>
    <<select(body_mass_g, year)>>

???

c(
    "Did you use the right function?" != search_ast(.code, .fn = select),
    "Did you pick the right variable?" != all(c("body_mass_g", "year") %in% all.vars(.code))
)
```

### Selection helpers

There are many helper functions that allow you to select variables by matching the patterns in the column's name. Let's look at a few examples.

* `starts_with()`: select all variables that start with a prefix.

```{r}
#| eval: false
penguins |>
    select(starts_with("bill"))
```

```{r}
#| echo: false
penguins |>
    select(starts_with("bill")) |>
    head()
```

* `ends_with()`: select all variables that ends with a suffix.

```{r}
#| eval: false
penguins |>
    select(ends_with("mm"))
```

```{r}
#| echo: false
penguins |>
    select(ends_with("mm")) |>
    head()
```

* `contains()`: select all variables that contains a literal string.

```{r}
#| eval: false
penguins |>
    select(contains("length"))
```

```{r}
#| echo: false
penguins |>
    select(contains("length")) |>
    head()
```

* `num_range()`: select all variables that matches a numerical range like x01, x02, x03.

```{r}
#| eval: false
billboard |>
    select(num_range("wk", 10:15))
```

```{r}
#| echo: false
billboard |> 
    select(num_range("wk", 10:15)) |>
    head()
```


## filter()

This allow you to extract observation from the data based on a given condition.

```{r}
#| eval: false

data |>
    filter(expression)
```

For the expression field, there are many functions and operators that are useful for constructing the expressions.

* `==`, `>`, `>=` etc
* `&`, `|`, `!`, `xor()`
* `is.na()`
* `between()`, `near()`

```{r}
#| eval: false
penguins |>
    filter(species = "Gentoo")
```

```{r}
#| echo: false
penguins |>
    filter(species == "Gentoo") |>
    head()
```


## arrange()

It is for sorting your data based on one or more variables. By default, it will arrange your data in ascending order. If you want to sort by descending order, it can be done using the `desc()` function.

```{r}
#| eval: false
penguins |>
    arrange(bill_length_mm)

penguins |>
    arrange(desc(bill_length_mm))
```

```{r}
#| echo: false
penguins |>
    arrange(bill_length_mm) |>
    head()

penguins |>
    arrange(desc(bill_length_mm)) |>
    head()
```

::: {.callout-tip}
## Did you know

What do you think will happen if you sort the penguin's data by the species where it is a character variable? If you guess that it will sort in **alphabetical order**, you are correct!!!
:::


## mutate()

This function is for creating new variable or modify the existing one.

```{r}
#| eval: false

data |>
    mutate(variable_name = value)
```

The **"variable_name"**, this can be the existing variable you are going to modify or  new variable name you are trying to create. The **"value"** is what will be assigned to the **"variable_name"**.

Here is an example on using mutata function to modify the **existing** variable

```{r}
#| eval: false
penguins |>
    mutate(sex = ifelse(sex == "male", "M", "F"))
```

```{r}
#| echo: false
penguins |>
    mutate(sex = ifelse(sex == "male", "M", "F")) |>
    select(species, sex) |>
    head()
```

::: {.callout-caution}
## Your turn!
Let said that you think that the body mass of the penguins should be expressed as kilogram instead of gram. How could you create a **new** variable? Make sure you name it as `body_mass_kg`.

Hint: The conversion from gram to kilogram can be expressed in a forms of $kg = g/1000$
:::

```{webr-teachr}
# library the packages needed
library(palmerpenguins)
library(dplyr)

# Select the column of interests
penguins |>
    <<mutate(body_mass_kg = body_mass_g/1000)>>

???

c(
    "Did you use the right function?" != search_ast(.code, .fn = mutate),
    "Did you provide the right expression?" != search_ast(.code, .expr = body_mass_g/1000)
)
```


## group_by()

It allows you to take the existing data and group the specific variables together for future operations. For example, with penguins data, if you want to rank penguins by weights within each species, instead of splitting the dataset by species, rank them individually and then rejoin the data. You can use the `group_by` function together with `mutate` to achieve the same operation.

```{r}
#| eval: false
penguins |>
    group_by(species) |>
    mutate(ranking = rank(body_mass_g, ties.method = "min")) |>
    ungroup()
```

```{r}
penguins |>
    group_by(species) |>
    mutate(ranking = rank(body_mass_g, ties.method = "min")) |>
    ungroup() |>
    select(species, body_mass_g, ranking) |>
    head()
```

:::{.callout-note}
It is a good practice to use the `ungroup` function after you have done the operations. If you have not **ungrouped** the data, whatever operations you do after will take into account the grouping whether you want it or not.
:::


## summarize()
As the name mentioned, it summarizes data into a new data frame based on the groupings and different arguments you included. The summary statistics are something you have to create very often. Here is an example of the summary statistics based on the penguin species.

```{r}
penguins |>
    group_by(species) |>
    summarize(
        Average_body_mass = mean(body_mass_g, na.rm = TRUE),
        Median_body_mass = median(body_mass_g, na.rm = TRUE),
        SD_body_mass = sd(body_mass_g, na.rm = TRUE))
```

:::{.callout-note}
The `na.rm` argument in the function is for ignoring the **NAs** values when calculating each statistic.
:::

:::{.callout-tip}
## Did you know

You may have noticed that we use the letter **z** in words like **summarize**. In British English, you might be more familiar with spelling it as **summarise**. In tidyverse, you can use either spelling when calling a function. So, whether you're used to writing summarize or summarising, the functionality is still the same either way.
:::